---
projectType: tutorial
source: https://www.udemy.com/course/graphql-by-example/learn/lecture/16580146#overview
instructor: Mirko Nasato
title: Server Authentication with WebSockets
details:
  section: 6
  lesson: 43
docs: https://github.com/gaurangrshah/_docs/blob/graphql/graphql/projects/udemy/graphql-job-board/setup.md
---



## Server Authentication with WebSockets



Now that we've got our client properly setting our authentication token, we'll need to setup our authentication handling for our client from our server. Currently our server does not know that it needs to enforce the authentication policy we've set in place with our authToken. In the end both the http protocol based queries and our websocket based subscriptions should be be required to undergo the same authentication process. 



We'll start by updating our subscription resolver:

```js
// resolvers.js

const Subscription = {
  messageAdded: {
    // 🔵 different from our other resolvers -- not a function but rather an object that has a subscribe() method
    subscribe: (_root, _args, context) => {
      console.log(context)
      // requireAuth(userId); 
      return pubSub.asyncIterator(MESSAGE_ADDED);
    },
  },
};
```

> subscription resolvers are a bit different in that here `messageAdded` is not a function, but rather an object that has a `subscribe()` method. In either case it still has the same access to the arguments that any of our other resovlers do -- so in terms of functionality will remain somewhat similar.
>
> Above we've logged out the details received by our subscribe method to see what the context object holds for us -- if we look in our node console:
>
> ```shell
> [nodemon] restarting due to changes...
> [nodemon] starting `node server.js`
> [nodemon] restarting due to changes...
> [nodemon] starting `node server.js`
> Server started on port 9000
> 
> messageAdded(context) { context: {} }
> ```
>
> We can see that the context in our subscription is in fact empty.



This is because when we setup our authentication, we made the user available via the context, but we set the user from the returned user object that we get in our response from `http` requests. In our case with WebSockets, we're no longer opting into the same request/response paradigm, so there is no context being set because there was never an http request made. We'll need to update our logic to ensure that we're setting the correct context for either type of request:

```js
// server.js

// ❌ function context({ req }) {
function context(params) {
  console.log("context -> params", Object.keys(params));
  const { req } = params;
  if (req && req.user) {
    return { userId: req.user.sub };
  }
  return {};
}

```

> we simply want to debug our params, but we updated to code to make sure we're still performing the original logic
>
> ```shell
> Server started on port 9000
> context -> params [ 'req', 'res' ]
> context -> params [ 'connection', 'payload' ]
> messageAdded(context) { context: {} }
> context -> params [ 'req', 'res' ]
> context -> params [ 'req', 'res' ]
> context -> params [ 'req', 'res' ]
> ```
>
> Not we're logging out  our message repeatedly, this is because we've established our websocket connecting and it will keep pining the server for us to keep the connection alive. 
>
> Not that every time we see `req` and `res` logged represents an http request where as the `connection` and `payload` properties represent our `websocket` connection.
>
> This tell us that similar to how we receive the `userId` from the `req` we can use the same implementation to get the `userId` from the `connection` object as well.



**NOTE** we'll want to make sure our code still handles both `http` and `ws` requests:

```js
// server.js

// ❌ function context({ req }) {
function context({ req, connection }) {
  if (req && req.user) {
    return { userId: req.user.sub };
  }
  if (connection) {
    console.log(connection);
  }
  return {};
}
```

> ```shell
> Server started on port 9000
> {
>   query: 'subscription {\n' +
>     '  messageAdded {\n' +
>     '    id\n' +
>     '    from\n' +
>     '    text\n' +
>     '    __typename\n' +
>     '  }\n' +
>     '}\n',
>   variables: {},
>   operationName: null,
>   context: {
>     accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhbGljZSIsImlhdCI6MTYwMzA0NjcxMn0.QSRZZwHRgy5aanWnA4mNHNwfW5I0hZD71SuExmRQfOA'
>   },
>   formatResponse: [Function (anonymous)],
>   formatError: undefined,
>   callback: undefined,
>   schema: GraphQLSchema {
>     __validationErrors: [],
>     extensions: undefined,
>     astNode: undefined,
>     extensionASTNodes: undefined,
>     __allowedLegacyNames: [],
>     _queryType: Query,
>     _mutationType: Mutation,
>     _subscriptionType: Subscription,
>     _directives: [ @cacheControl, @skip, @include, @deprecated ],
>     _typeMap: [Object: null prototype] {
>       Query: Query,
>       Message: Message,
>       ID: ID,
>       String: String,
>       Mutation: Mutation,
>       MessageInput: MessageInput,
>       Subscription: Subscription,
>       __Schema: __Schema,
>       __Type: __Type,
>       __TypeKind: __TypeKind,
>       Boolean: Boolean,
>       __Field: __Field,
>       __InputValue: __InputValue,
>       __EnumValue: __EnumValue,
>       __Directive: __Directive,
>       __DirectiveLocation: __DirectiveLocation,
>       CacheControlScope: CacheControlScope,
>       Upload: Upload,
>       Int: Int
>     },
>     _possibleTypeMap: [Object: null prototype] {},
>     _implementations: [Object: null prototype] {}
>   }
> }
> ```
>
> **NOTE:** the `accessToken` property is present on the context in our `connection` object



There's one more caveat between `http` and `ws` protocols when it comes to authentication, our `http` requests automatically recieve the user object appended onto the `req.user` property, where as for `ws` we have no similiar preconfigured avenue, so we'll need to also handle the decoding and verification of our token manually as well. 

```js
// server.js

if (connection) {
  // if connection then authenticate as a websocket connection, 
  const decodedToken = jwt.verify(connection.context.accessToken, jwtSecret)
  console.log("context -> decodedToken", { decodedToken });
}
```

> We can see that our user id is available from the `decodedToken.sub` property:
>
> ```shell
> [nodemon] restarting due to changes...
> [nodemon] starting `node server.js`
> [nodemon] restarting due to changes...
> [nodemon] starting `node server.js`
> Server started on port 9000
> 
> context -> decodedToken { decodedToken: { sub: 'alice', iat: 1603047857 } }
> ```



So now we can make sure we're setting the right property to handle our auth for our websocket connections

```js
// server.js

  if (connection && connection.context && connection.context.accessToken) {
    // if connection then authenticate as a websocket connection,
    const decodedToken = jwt.verify(connection.context.accessToken, jwtSecret);
    // add decoded userId to context
    if (!decodedToken.sub) console.log("missing user id");
    return { userId: decodedToken.sub };
  }
```



Lastly we have one final step to update our resolvers to grab the correct user id that we've just set:

```js
// resolvers.js

const Subscription = {
  messageAdded: {
    // ❌ subscribe: (_root, _args, context) => {
    subscribe: (_root, _args, { userId }) => {
      requireAuth(userId); // used to enforce auth for websocket connections
      return pubSub.asyncIterator(MESSAGE_ADDED);
    },
  },
};
```

